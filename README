    sub wait { my $self = shift; # $self->log('waitR:', join(',',@_)); my (
    $waits, $wait_once ) = @_; # $self->log('dctim', "[$self->{'number'}]
    waitR[$waits, , $wait_once]"); $waits ||= $self->{'waits'}; $wait_once
    ||= $self->{'wait_once'}; local $_; my $ret; # $self->log('dctim',
    "[$self->{'number'}] wait [$waits, $ret, $wait_once]"), $ret +=
    $self->recv($wait_once) while --$waits > 0 and !$ret; #
    $self->log('dctim', "[$self->{'number'}] waitret"); return $ret; }

    sub finished { my $self = shift; $self->log( 'dcdev',
    "[$self->{'number'}]", 'not finished file:', "$self->{'filebytes'} /
    $self->{'filetotal'}", $self->{'peernick'} ), return 0 if (
    $self->{'filebytes'} and $self->{'filetotal'} and $self->{'filebytes'} <
    $self->{'filetotal'} - 1 ); local @_; $self->log( 'dcdev',
    "[$self->{'number'}]", 'not finished clients:', @_ ), return 0 if @_ =
    grep { !$self->{'clients'}{$_}->finished() } keys %{ $self->{'clients'}
    }; return 1; }

    sub wait_connect { my $self = shift; for ( 0 .. ( $_[0] ||
    $self->{'wait_connect'} ) ) { last if $self->{'status'} eq 'connected';
    $self->wait(); } }

    sub wait_finish { my $self = shift; for ( 0 .. $self->{'wait_finish'} )
    { last if $self->finished(); $self->wait( undef,
    $self->{'wait_finish_by'} ); } local @_; $self->info(), $self->log(
    'info', 'finished, but clients still active:', map {
    "[$self->{'clients'}{$_}{'number'}]$_;st=$self->{'clients'}{$_}{'status'
    }" } @_ ) if @_ = keys %{ $self->{'clients'} }; }

    sub wait_clients { my $self = shift; for ( 0 .. $self->{'wait_clients'}
    ) { last if $self->{'clients_max'} > scalar keys %{ $self->{'clients'}
    }; $self->info() unless $_; $self->log( 'info', "wait clients " .
    scalar( keys %{ $self->{'clients'} } ) . "/$self->{'clients_max'}
    $_/$self->{'wait_clients'}" ); # $self->log( 'info', "wait RUN", undef,
    $self->{'wait_clients_by'} ); $self->wait( undef,
    $self->{'wait_clients_by'} ); } }

    sub wait_sleep { my $self = shift; my $how = shift || 1; my $starttime =
    time(); $self->wait(@_) while $starttime + $how > time(); }

    sub work { my $self = shift; my @params = @_; $self->{'periodic'}->() if
    ref $self->{'periodic'} eq 'CODE'; return $self->wait_sleep(@params) if
    @params; return $self->recv( $self->{'work_sleep'} ); }

    sub parse { my $self = shift; for ( local @_ = @_ ) { s/^\$(\w+)\s*//;
    my $cmd = $1; my ( @ret, $ret ); #print "[$self->{'number'}]
    CMD:[$cmd]{$_}\n" unless $cmd eq 'Search'; $self->handler( $cmd .
    '_parse_bef_bef', $_ ); if ( $self->{'parse'}{$cmd} ) { if ( !exists
    $self->{'no_print'}{$cmd} #( $self->{'print_search'} or $cmd ne 'Search'
    ) and ( $self->{'print_myinfo'} or $cmd ne 'MyINFO' ) ) { local $_ = $_;
    local @_ = map { "$_:$self->{'skip_print_'.$_}" } grep { $self->{
    'skip_print_' . $_ } } keys %{ $self->{'no_print'} || {} }; $self->log(
    'dcdmp', "[$self->{'number'}] rcv: $cmd $_", ( @_ ? ( ' [', @_, ']' ) :
    () ) # ( $self->{'skip_print_search'} ? ", skipped searches:
    $self->{'skip_print_search'}" : () ), # ( $self->{'skip_print_myinfo'} ?
    ", skipped myinfos: $self->{'skip_print_myinfo'}" : () ), ); $self->{
    'skip_print_' . $_ } = 0 for keys %{ $self->{'no_print'} || {} }; #
    $self->{'skip_print_search'} = $self->{'skip_print_myinfo'} = 0; } else
    { # ++$self->{'skip_print_search'} if !$self->{'print_search'} and $cmd
    eq 'Search'; # ++$self->{'skip_print_myinfo'} if
    !$self->{'print_myinfo'} and $cmd eq 'MyINFO'; ++$self->{ 'skip_print_'
    . $cmd }, #printlog('dcdev', 'savenoprint', $cmd,
    $self->{'skip_print_'.$cmd}), if exists $self->{'no_print'}{$cmd}; }
    #print "[$self->{'number'}] rcv: $cmd $_\n" if $cmd ne 'Search' and
    $self->{'debug'}; $self->handler( $cmd . '_parse_bef', $_ ); @ret =
    $self->{'parse'}{$cmd}->($_); $ret = scalar @ret > 1 ? \@ret : $ret[0];
    $self->handler( $cmd . '_parse_aft', $_, $ret ); } else { $self->log(
    'dcinf', "[$self->{'number'}] UNKNOWN PEERCMD:[$cmd]{$_} : please add
    \$dc->{'parse'}{'$cmd'} = sub { ... };" ); $self->{'parse'}{$cmd} = sub
    { }; } $self->handler( $cmd, $_, $ret ); $self->handler( $cmd .
    '_parse_aft_aft', $_, $ret ); } }

    sub handler { my ( $self, $cmd ) = ( shift, shift ); # $self->log('dev',
    "handlerdbg [$cmd]", @_, $self->{'handler'}{$cmd});
    $self->{'handler_int'}{$cmd}->( $self, @_ ) if ref
    $self->{'handler_int'}{$cmd} eq 'CODE'; #internal lib
    $self->{'handler'}{$cmd}->( $self, @_ ) if ref $self->{'handler'}{$cmd}
    eq 'CODE'; } { my @sendbuf;

      sub sendcmd {
        my $self = shift;
        $self->connect_check();
        $self->log( 'err', "[$self->{'number'}] ERROR! no socket to send" ), return unless $self->{'socket'};
        if ( $self->{'sendbuf'} ) { push @sendbuf, '$' . join( ' ', @_ ) . '|'; }
        else {
          local $_;
    #$self->log( "atmark:", $self->{'socket'}->atmark, " timeout=",$self->{'socket'}->timeout,  'conn=',$self->{'socket'}->connected,'so=', $self->{'socket'});
          eval { $_ = $self->{'socket'}->send( join( '', @sendbuf, '$' . join( ' ', @_ ) . '|' ) ); };
          $self->log( 'err', "[$self->{'number'}]", 'send error', $@ ) if $@;
          $self->log( 'dcdmp', "[$self->{'number'}] we send [", join( '', @sendbuf, '$' . join( ' ', @_ ) . '|' ), "]:", $_, $! );
          @sendbuf = ();
        }
      }
    }

    sub cmd { #print "CMD PRE param[",@_,"]\n" ; my $self = shift; my $cmd =
    shift; my ( @ret, $ret ); $self->handler( $cmd . '_cmd_bef_bef', @_ );
    if ( $self->{'min_cmd_delay'} and ( time - $self->{'last_cmd_time'} <
    $self->{'min_cmd_delay'} ) ) { $self->{'log'}->( 'dbg', 'sleepcmd',
    $self->{'min_cmd_delay'} - time + $self->{'last_cmd_time'} ); sleep(
    $self->{'min_cmd_delay'} - time + $self->{'last_cmd_time'} ); }
    $self->{'last_cmd_time'} = time; if ( $self->{'cmd'}{$cmd} ) {
    $self->handler( $cmd . '_cmd_bef', @_ ); @ret =
    $self->{'cmd'}{$cmd}->(@_); $ret = scalar @ret > 1 ? \@ret : $ret[0];
    $self->handler( $cmd . '_cmd_aft', \@_, $ret ); } else { $self->log(
    'info', "[$self->{'number'}]", "UNKNOWN CMD:[$cmd]{@_} : please add
    \$dc->{'cmd'}{'$cmd'} = sub { ... };" ); $self->{'cmd'}{$cmd} = sub { };
    } if ( $self->{'auto_wait'} ) { $self->wait(); } elsif (
    $self->{'auto_recv'} ) { $self->recv(); } $self->handler( $cmd .
    '_cmd_aft_aft', @_, $ret ); }

    sub rcmd { my $self = shift; eval { eval { $_->cmd(@_) },
    $self->wait_sleep( $self->{'cmd_recurse_sleep'} ) for grep { $_ }
    values( %{ $self->{'clients'} } ), $self; }; # $self->cmd(@_); }

    sub get { my ( $self, $nick, $file, $as ) = @_; $self->wait_clients();
    $self->{'want'}->{$nick}{$file} = ( $as or $file ); $self->cmd( ( (
    $self->{'M'} eq 'A' and $self->{'myip'} and !$self->{'passive_get'} ) ?
    '' : 'Rev' ) . 'ConnectToMe', $nick ); }

    sub openfile { my $self = shift; my $oparam = ( ( $self->{'fileas'} eq
    '-' ) ? '>-' : '>' . ( $self->{'fileas'} || $self->{'filename'} ) );
    $self->handler( 'openfile_bef', $oparam ); $self->log( 'dbg',
    "[$self->{'number'}] openfile pre", $oparam ); open(
    $self->{'filehandle'}, $oparam ) or $self->log( 'dcerr',
    "[$self->{'number'}] openfile error", $!, $oparam ), $self->handler(
    'openfile_error', $!, $oparam ), return 1; binmode(
    $self->{'filehandle'} ); $self->handler('openfile_aft');
    $self->{'status'} = 'transfer'; return 0; }

    sub writefile { my $self = shift; $self->{'file_start_time'} ||= time;
    $self->handler('writefile_bef'); my $fh = $self->{'filehandle'} ||
    return; for my $databuf (@_) { $self->{'filebytes'} += length $$databuf;
    # $self->log( 'dcdbg', "($self->{'number'}) recv ".length($$databuf)."
    [$self->{'filebytes'}] of $self->{'filetotal'} file $self->{'filename'}"
    ); $self->log( 'dcdbg', "[$self->{'number'}] recv " . length($$databuf)
    . " [$$databuf]" ) if length $$databuf < 10; print $fh $$databuf;
    $self->log( 'err', "[$self->{'number'}] file download error! extra bytes
    ($self->{'filebytes'}/$self->{'filetotal'}) " ) if $self->{'filebytes'}
    > $self->{'filetotal'}; # close($fh), $self->log( 'info',
    "[$self->{'number'}] file complete ($self->{'filebytes'}) per",
    $self->float( time - $self->{'file_start_time'} ), 's at', $self->float(
    $self->{'filebytes'} / ( ( time - $self->{'file_start_time'} ) or 1 ) ),
    'b/s' ), $self->disconnect(), $self->{'status'} = 'destroy',
    $self->{'file_start_time'} = 0 if $self->{'filebytes'} >=
    $self->{'filetotal'}; } }

    sub get_peer_addr { my ($self) = @_; return unless $self->{'socket'};
    eval { @_ = unpack_sockaddr_in( getpeername( $self->{'socket'} ) ) };
    return unless $_[1]; return unless $_[1] = inet_ntoa( $_[1] );
    $self->{'port'} = $_[0] if $_[0] and !$self->{'incoming'}; return
    $self->{'host'} = $_[1] if $_[1]; }

    sub get_my_addr { my ($self) = @_; return unless $self->{'socket'}; eval
    { @_ = unpack_sockaddr_in( getsockname( $self->{'socket'} ) ) }; return
    unless $_[1]; return unless $_[1] = inet_ntoa( $_[1] ); #
    $self->{'log'}->('dev', "MYIP($self->{'myip'}) [$self->{'number'}]
    SOCKNAME $_[0],$_[1];"); return $self->{'myip'} ||= $_[1]; } #
    http://www.dcpp.net/wiki/index.php/LockToKey : sub lock2key { my @lock =
    split( //, shift ); my $i; my @key = (); # convert to ordinal foreach
    (@lock) { $_ = ord; } # calc key[0] with some xor-ing magic push( @key,
    $lock[0] ^ 5 ); # calc rest of key with some other xor-ing magic for (
    $i = 1 ; $i < @lock ; $i++ ) { push( @key, ( $lock[$i] ^ $lock[ $i - 1 ]
    ) ); } # nibble swapping for ( $i = 0 ; $i < @key ; $i++ ) { $key[$i] =
    ( ( ( $key[$i] << 4 ) & 240 ) | ( ( $key[$i] >> 4 ) & 15 ) ) & 0xff; }
    #temp[0] = (u_int8_t)(temp[0] ^ temp[aLock.length()-1]); $key[0] =
    $key[0] ^ $key[ @key - 1 ]; # escape some foreach (@key) { if ( $_ == 0
    || $_ == 5 || $_ == 36 || $_ == 96 || $_ == 124 || $_ == 126 ) { $_ =
    sprintf( '/%%DCN%03i%%/', $_ ); } else { $_ = chr; } } # done return
    join( '', @key ); }

    sub tag { my $self = shift; $self->{'client'} . ' ' . join( ',', map $_
    . ':' . $self->{$_}, grep defined( $self->{$_} ), qw(V M H S O) ); }

    sub myinfo { my $self = shift; return $self->{'Nick'} . ' ' .
    $self->{'description'} . '<' . $self->tag() . '>' . '$' . ' ' . '$' .
    $self->{'connection'} . ( length( $self->{'flag'} ) ? chr(
    $self->{'flag'} ) : '' ) . '$' . $self->{'email'} . '$' .
    $self->{'sharesize'} . '$'; }

    sub supports { my $self = shift; return join ' ', grep $self->{$_}, @{
    $self->{'supports_avail'} }; }

    sub supports_parse { my $self = shift; my ( $str, $save ) = @_;
    $save->{$_} = 1 for split /\s+/, $str; delete $save->{$_} for grep
    !length $save->{$_}, keys %$save; return wantarray ? %$save : $save; }

    sub info_parse { my $self = shift; my ( $info, $save ) = @_;
    $save->{'info'} = $info; $save->{'description'} = $1 if $info =~
    s/^([^<\$]+)(<|\$)/$2/; ( $save->{'tag'}, $save->{'M'},
    $save->{'connection'}, $save->{'email'}, $save->{'sharesize'} ) = split
    /\s*\$\s*/, $info; $save->{'flag'} = ord($1) if $save->{'connection'} =~
    s/([\x00-\x1F])$//e; $self->tag_parse( $save->{'tag'}, $save ); delete
    $save->{$_} for grep !length $save->{$_}, keys %$save; return wantarray
    ? %$save : $save; }

    sub tag_parse { my $self = shift; my ( $tag, $save ) = @_;
    $save->{'tag'} = $tag; $tag =~ s/(^\s*<\s*)|(\s*>\s*$)//g;
    $save->{'client'} = $1 if $tag =~ s/^(\S+)\s*//; /(.+):(.+)/,
    $save->{$1} = $2 for split /,/, $tag; return wantarray ? %$save : $save;
    }

    sub info { my $self = shift; #local @_ = $self->active(); #
    $self->log('info', 'active', @_) if @_; $self->log( 'info', map(
    {"$_=$self->{$_}"} grep { $self->{$_} } @{ $self->{'informative'} } ),
    map( { $_ . '(' . scalar( keys %{ $self->{$_} } ) . ')=' . join( ',',
    keys %{ $self->{$_} } ) } grep { keys %{ $self->{$_} } } @{
    $self->{'informative_hash'} } ) ); $self->{'clients'}{$_}->info() for
    keys %{ $self->{'clients'} }; } #sub active { my $self = shift; return
    map { $_->{'number'} } grep { $_->{'socket'} } $self, values %{
    $self->{'clients'} };} sub active { my $self = shift; return 1 if grep {
    $self->{'status'} eq $_ } qw(connecting connected reconnecting listening
    transfer); return 0; } #sub status { #now states: #listening connecting
    connected reconnecting transfer disconnected destroy #need checks: # \
    connected?/ \-----/
    #\-----------------------active?-------------------------/ #} #my
    %every; sub every { my ( $self, $sec, $func ) = ( shift, shift, shift );
    #printlog('dev','every', $sec, $every{$func}, time, $func ),
    $func->(@_), $self->{'every'}{$func} = time if $self->{'every'}{$func} +
    $sec < time and ref $func eq 'CODE'; }

    sub AUTOLOAD { my $self = shift || return; my $type = ref($self) ||
    return; my $name = $AUTOLOAD; $name =~ s/.*://; #print "CMD[", Dumper
    ($self), " : $type];\n"; return $self->cmd( $name, @_ ); } 1;

    __END__

NAME
    Net::DirectConnect - Perl Direct Connect protocol implementation

SYNOPSIS
      use Net::DirectConnect::clihub;
      my $dc = Net::DirectConnect::clihub->new(
        'host' => 'dc.mynet.com',
        'port' => '4111', #if not 411
        'Nick' => 'Bender', 
        'description' => 'kill all humans',
        'M'           => 'P', #passive mode, active by default
      );
      while ( $dc->active() ) {
        $dc->work();    
      }
      $dc->destroy();

    look at examples for handlers

DESCRIPTION
INSTALLATION
    To install this module type the following:

       perl Makefile.PL
       make
       make test
       make install

SEE ALSO
    # pro http://pro.setun.net/dcppp/ http://sourceforge.net/projects/dcppp

    latest snapshot svn co svn://svn.setun.net/dcppp/trunk/ dcppp

    usage example: used in [and created for]
    http://sourceforge.net/projects/pro-search (
    http://pro.setun.net/search/trac.cgi/browser/trunk/crawler.pl )

    protocol info: http://en.wikipedia.org/wiki/Direct_Connect_network
    http://www.teamfair.info/DC-Protocol.htm

    also useful for creating links from web:
    http://magnet-uri.sourceforge.net/
    http://en.wikipedia.org/wiki/Magnet:_URI_scheme

AUTHOR
    Oleg Alexeenkov, <pro@cpan.org>

COPYRIGHT AND LICENSE
    Copyright (C) 2005-2009 Oleg Alexeenkov

    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself, either Perl version 5.10.0 or, at
    your option, any later version of Perl 5 you may have available.

